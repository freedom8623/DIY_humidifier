C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 11:31:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Driver;.\User) DEBUG OBJEC
                    -TEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          #include "Gpio.h"
   3          #include "Timer.h"
   4          #include "DHT.h"
   5          #include "oled.h"
   6          
   7          //蜂鸣器
   8          sbit Buzzer = P3^7;
   9          //水位检测引脚
  10          sbit Water_test = P3^6;
  11          
  12          
  13          sbit KEY1 = P3^2;
  14          sbit KEY2 = P3^3;
  15          sbit KEY3 = P3^4;
  16          sbit KEY4 = P3^5;
  17          
  18          //DHT11查询函数
  19          void DHT_Read(void);
  20          //按键函数
  21          void Key_Proc(void);
  22          //水位
  23          void Alertor(void);
  24          
  25          
  26          uchar i = 0;
  27          //按键
  28          struct keys key[4] = {0,0,0};
  29          uchar Key_T = 0;
  30          //按键的结构体 结构体在Timer.h
  31          extern struct keys key[];
  32          
  33          //定时器1ns
  34          int T_Tick;//一毫米累加
  35          
  36          void main(void)
  37          { 
  38   1        Gpio_init();//GPIO初始化
  39   1        Timer2_init();//定时器初始化
  40   1        DHT_Start();
  41   1        //OLED初始化
  42   1        OLED_Init();      //初始化OLED  
  43   1        OLED_Clear()    ; 
  44   1        
  45   1        //相关开关
  46   1        EA = 1;     //打开总中断
  47   1        
  48   1      
  49   1        while(1)
  50   1        {
  51   2          Buzzer = 1;//测试蜂鸣器
  52   2          Key_Proc();
  53   2          DHT_Read();
  54   2          Alertor();
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 11:31:26 PAGE 2   

  55   2          
  56   2        }
  57   1      }
  58          
  59          
  60          //每500ms查询温湿度
  61          char DHT_Read_Flag = 0;
  62          void DHT_Read()
  63          {
  64   1        if(T_Tick%500==0) DHT_Read_Flag = 1;
  65   1        else return;
  66   1        
  67   1        if(DHT_Read_Flag ==1)
  68   1        {
  69   2          DHT11_Read();
  70   2        }
  71   1      }
  72          
  73          //定时器中断
  74          void timer2_int (void) interrupt 12
  75          {
  76   1        T_Tick ++;
  77   1        if(T_Tick>10000) T_Tick = 0;
  78   1            //第一步读取按键状态
  79   1            key[0].key_sta = KEY1;
  80   1            key[1].key_sta = KEY2;
  81   1            key[2].key_sta = KEY3;
  82   1            key[3].key_sta = KEY4;
  83   1        
  84   1          //遍历
  85   1          for(i = 0;i <4; i++)
  86   1          {
  87   2            switch(key[i].judge_sta)
  88   2            {
  89   3              case 0 :
  90   3              {
  91   4                //第一步是为了消抖
  92   4              if(key[i].key_sta == 0)
  93   4                {
  94   5                key[i].judge_sta = 1;
  95   5                key[i].key_time = 0;
  96   5                
  97   5                }
  98   4              }
  99   3                break;
 100   3                
 101   3              case 1 :
 102   3              {
 103   4              //如果key_sta == 0证明按键确实被按下
 104   4              if(key[i].key_sta == 0)
 105   4                {
 106   5                  key[i].judge_sta = 2;
 107   5      
 108   5                }
 109   4              else
 110   4                {
 111   5                key[i].judge_sta = 0;
 112   5                }
 113   4              }
 114   3              break;
 115   3                        
 116   3              case 2 :
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 11:31:26 PAGE 3   

 117   3              {
 118   4                //证明按下后松手
 119   4                  if(key[i].key_sta == 1)
 120   4                {
 121   5                  key[i].judge_sta = 0;
 122   5                      //确定是否为短按
 123   5                  if(key[i].key_time<=70)
 124   5                    {
 125   6                    key[i].single_flag = 1;
 126   6                    }
 127   5                  
 128   5                }
 129   4                  else
 130   4                {
 131   5                  key[i].key_time++;
 132   5                  //判断如果按下时间大于70ms长按标志位置为1
 133   5                  if(key[i].key_time>70)
 134   5                    key[i].longkey_falg = 1;
 135   5                }
 136   4              }
 137   3              break;
 138   3                        
 139   3            }       
 140   2          }
 141   1      }
 142          
 143          //按键进程
 144          void Key_Proc(void)
 145          {
 146   1        if(key[0].single_flag == 1)
 147   1        {
 148   2          
 149   2          key[0].single_flag = 0;
 150   2        
 151   2        }
 152   1        
 153   1         if(key[1].single_flag == 1)
 154   1        {
 155   2          
 156   2          key[1].single_flag = 0;
 157   2        
 158   2        }
 159   1        
 160   1         if(key[2].single_flag == 1)
 161   1        {
 162   2          
 163   2          key[2].single_flag = 0;
 164   2        
 165   2        }
 166   1        
 167   1        if(key[3].single_flag == 1)
 168   1        {
 169   2          
 170   2          key[3].single_flag = 0;
 171   2        
 172   2        }
 173   1      }
 174          
 175          //蜂鸣器进程
 176          char Water_Flag = 0;
 177          void Alertor(void)
 178          {
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 11:31:26 PAGE 4   

 179   1        if(T_Tick%500==0) Water_Flag = 1;
 180   1        else return;
 181   1        
 182   1        if(Water_test == 1)
 183   1        {
 184   2          Buzzer = 1;
 185   2          Water_Flag = 0;
 186   2        }else
 187   1        {
 188   2          Buzzer = 0;
 189   2        }
 190   1      }
 191          
 192          //测水位进程
 193          
 194          
 195          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    439    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     38    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
