C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 17:32:27 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE User\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Driver;.\User) DEBUG OBJEC
                    -TEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          #include "Gpio.h"
   3          #include "Timer.h"
   4          #include "DHT.h"
   5          #include "Pwm.h"
   6          #include "oled.h"
   7          
   8          //蜂鸣器
   9          sbit Buzzer = P3^7;
  10          //水位检测引脚
  11          sbit test = P2^4;
  12          sbit Water_test = P1^1;
  13          
  14          
  15          
  16          sbit test2 =P2^3 ;
  17          
  18          sbit KEY1 = P3^2;
  19          sbit KEY2 = P3^3;
  20          sbit KEY3 = P3^4;
  21          sbit KEY4 = P3^5;
  22          
  23          //DHT11查询函数
  24          void DHT_Read(void);
  25          //按键函数
  26          void Key_Proc(void);
  27          //水位
  28          void Alertor(void);
  29          //OLED 显示函数
  30          void Display_Screen(void);
  31          void Setting_Pwm(u16 Duty1,u16 Duty2);
  32          //pwm占空比
  33          extern u16 PWM1_Duty;
  34          extern u16 PWM2_Duty;
  35          
  36          //按键
  37          struct keys key[4] = {0,0,0};
  38          uchar Key_T = 0;
  39          //按键的结构体 结构体在Timer.h
  40          extern struct keys key[];
  41          
  42          //定时器1ns
  43          int T_Tick;//一毫米累加
  44          
  45          void main(void)
  46          { 
  47   1        Gpio_init();//GPIO初始化
  48   1      //  Timer2_init();//定时器初始化
  49   1        
  50   1        //Pwm_init();//产生pwm;占空比50%
  51   1        //UpdatePwm();//更新占空比   //在PWM.C中更改占空比使得产生频率为108khz
  52   1        //DHT_Start();//温湿度
  53   1        
  54   1        
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 17:32:27 PAGE 2   

  55   1        //OLED初始化
  56   1        oled_Init();      //初始化OLED  
  57   1        oled_clear()    ; 
  58   1        oled_ShowStr(0,0,"1124'xiaolala",16);
  59   1        
  60   1        //相关开关
  61   1        EA = 1;     //打开总中断
  62   1      
  63   1        //Buzzer = 1;
  64   1        while(1)
  65   1        {
  66   2          
  67   2          P11  = 1;
  68   2          //test = 0;
  69   2          Buzzer = 0;//测试蜂鸣器
  70   2          
  71   2          test2 = 0;
  72   2      //    Key_Proc();
  73   2          //DHT_Read();
  74   2          //Alertor();
  75   2          //Display_Screen();
  76   2          
  77   2        }
  78   1      }
  79          
  80          
  81          //每500ms查询温湿度
  82          char DHT_Read_Flag = 0;
  83          void DHT_Read()
  84          {
  85   1        if(T_Tick%500==0) DHT_Read_Flag = 1;
  86   1        else return;
  87   1        
  88   1        if(DHT_Read_Flag ==1)
  89   1        {
  90   2          DHT11_Read();
  91   2        }
  92   1      }
  93          
  94          //定时器中断
  95          void timer2_int (void) interrupt 12
  96          {
  97   1        uchar i = 0;
  98   1        T_Tick ++;
  99   1        if(T_Tick>10000) T_Tick = 0;
 100   1            //第一步读取按键状态
 101   1            key[0].key_sta = KEY1;
 102   1            key[1].key_sta = KEY2;
 103   1            key[2].key_sta = KEY3;
 104   1            key[3].key_sta = KEY4;
 105   1        
 106   1          //遍历
 107   1          for(i = 0;i <4; i++)
 108   1          {
 109   2            switch(key[i].judge_sta)
 110   2            {
 111   3              case 0 :
 112   3              {
 113   4                //第一步是为了消抖
 114   4              if(key[i].key_sta == 0)
 115   4                {
 116   5                key[i].judge_sta = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 17:32:27 PAGE 3   

 117   5                key[i].key_time = 0;
 118   5                
 119   5                }
 120   4              }
 121   3                break;
 122   3                
 123   3              case 1 :
 124   3              {
 125   4              //如果key_sta == 0证明按键确实被按下
 126   4              if(key[i].key_sta == 0)
 127   4                {
 128   5                  key[i].judge_sta = 2;
 129   5      
 130   5                }
 131   4              else
 132   4                {
 133   5                key[i].judge_sta = 0;
 134   5                }
 135   4              }
 136   3              break;
 137   3                        
 138   3              case 2 :
 139   3              {
 140   4                //证明按下后松手
 141   4                  if(key[i].key_sta == 1)
 142   4                {
 143   5                  key[i].judge_sta = 0;
 144   5                      //确定是否为短按
 145   5                  if(key[i].key_time<=70)
 146   5                    {
 147   6                    key[i].single_flag = 1;
 148   6                    }
 149   5                  
 150   5                }
 151   4                  else
 152   4                {
 153   5                  key[i].key_time++;
 154   5                  //判断如果按下时间大于70ms长按标志位置为1
 155   5                  if(key[i].key_time>70)
 156   5                    key[i].longkey_falg = 1;
 157   5                }
 158   4              }
 159   3              break;
 160   3                        
 161   3            }       
 162   2          }
 163   1      }
 164          
 165          
 166          char Show_Flag = 0;
 167          void Display_Screen(void)
 168          {
 169   1        if(T_Tick%100==0) Show_Flag = 1;
 170   1        else return;
 171   1        
 172   1      }
 173          
 174          //按键处理
 175          void Key_Proc(void)
 176          {
 177   1        if(key[0].single_flag == 1)
 178   1        {
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 17:32:27 PAGE 4   

 179   2          Buzzer ^= 1; 
 180   2          key[0].single_flag = 0;
 181   2        
 182   2        }
 183   1        
 184   1         if(key[1].single_flag == 1)
 185   1        {
 186   2          test2 ^= 1;
 187   2          
 188   2          key[1].single_flag = 0;
 189   2        
 190   2        }
 191   1        
 192   1         if(key[2].single_flag == 1)
 193   1        {
 194   2          
 195   2          key[2].single_flag = 0;
 196   2        
 197   2        }
 198   1        
 199   1        if(key[3].single_flag == 1)
 200   1        {
 201   2          
 202   2          key[3].single_flag = 0;
 203   2        
 204   2        }
 205   1      }
 206          
 207          //水位/蜂鸣器（报警器）进程
 208          char Water_Flag = 0;
 209          void Alertor(void)
 210          {
 211   1        if(T_Tick%500==0) Water_Flag = 1;
 212   1        else return;
 213   1        
 214   1        if(Water_test == 1)
 215   1        {
 216   2          Buzzer = 1;
 217   2          Water_Flag = 0;
 218   2        }else
 219   1        {
 220   2          Buzzer = 0;
 221   2        }
 222   1      }
 223          
 224          void Setting_Pwm(u16 Duty1,u16 Duty2)
 225          {
 226   1          PWM1_Duty = Duty1;
 227   1          PWM2_Duty = Duty2;
 228   1        
 229   1          UpdatePwm();
 230   1      }
 231          
 232          
 233          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    471    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              12/04/2023 17:32:27 PAGE 5   

   DATA SIZE        =     38    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
